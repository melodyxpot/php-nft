'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ExchangePaymentMedium = require('bitcoin-exchange-client').PaymentMedium;
var PaymentAccount = require('./payment-account');
var Trade = require('./trade');
var BankAccount = require('./bank-account');

var PaymentMedium = function (_ExchangePaymentMediu) {
  _inherits(PaymentMedium, _ExchangePaymentMediu);

  function PaymentMedium(obj, api, quote) {
    _classCallCheck(this, PaymentMedium);

    var _this = _possibleConstructorReturn(this, (PaymentMedium.__proto__ || Object.getPrototypeOf(PaymentMedium)).call(this, api, quote, Trade));

    _this._TradeClass = Trade;

    _this._inMedium = obj.inMedium;
    _this._outMedium = obj.outMedium;
    _this._minimumInAmounts = obj.minimumInAmounts;
    _this._limitInAmounts = obj.limitInAmounts;

    /* istanbul ignore else */
    if (_this._inMedium === 'card' || _this._outMedium === 'card') {
      _this._fiatMedium = 'card';
    } else if (_this._inMedium === 'bank' || _this._outMedium === 'bank') {
      _this._fiatMedium = 'bank';
    } else {
      console.warn('Unknown fiat medium', _this._inMedium, _this._outMedium);
    }

    _this._name = obj.name;

    _this._inCurrencies = obj.inCurrencies;
    _this._outCurrencies = obj.outCurrencies;

    _this._inCurrency = obj.inCurrency;
    _this._outCurrency = obj.outCurrency;

    if (_this._inCurrency === 'BTC') {
      _this._inFixedFee = Math.round(obj.inFixedFee * 100000000);
      _this._outFixedFee = Math.round(obj.outFixedFee * 100);
    } else {
      _this._inFixedFee = Math.round(obj.inFixedFee * 100);
      _this._outFixedFee = Math.round(obj.outFixedFee * 100000000);
    }
    _this._inPercentageFee = obj.inPercentageFee;
    _this._outPercentageFee = obj.outPercentageFee;

    _this._bankId = obj.bankId;
    _this._bankAccount = obj.bankAccount;

    if (quote) {
      var amt = quote.baseCurrency === 'BTC' ? quote.quoteAmount : quote.baseAmount;
      var percentageFee = amt < 0 ? _this.inPercentageFee : -_this.outPercentageFee;
      _this._fee = Math.round(_this.inFixedFee + -amt * (percentageFee / 100));
      _this._total = -amt + _this._fee;
    }
    return _this;
  }

  _createClass(PaymentMedium, [{
    key: 'getAccounts',
    value: function getAccounts() {
      return Promise.resolve([new PaymentAccount(this._api, this.fiatMedium, this._quote)]);
    }

    // There are no PaymentAccounts when buying, so just call it directly:

  }, {
    key: 'buy',
    value: function buy() {
      var account = new PaymentAccount(this._api, this.fiatMedium, this._quote);
      return account.buy();
    }
  }, {
    key: 'getBankAccounts',
    value: function getBankAccounts() {
      var _this2 = this;

      if (this._fiatMedium === 'card') return;
      return BankAccount.getAll(this._api, this._quote).then(function (accounts) {
        _this2._accounts = accounts;
        return accounts;
      });
    }
  }, {
    key: 'addBankAccount',
    value: function addBankAccount(obj) {
      var _this3 = this;

      return BankAccount.add(obj, this._api, this._quote).then(function (res) {
        _this3._accounts.push(res);
        return res;
      });
    }
  }, {
    key: 'name',
    get: function get() {
      return this._name;
    }
  }, {
    key: 'limitInAmounts',
    get: function get() {
      return this._limitInAmounts;
    }
  }, {
    key: 'minimumInAmounts',
    get: function get() {
      return this._minimumInAmounts;
    }
  }], [{
    key: 'getAll',
    value: function getAll(inCurrency, outCurrency, api, quote) {
      var params = {};
      if (inCurrency) {
        /* including inCurrency restricts the response to only include limits in that one currency */
        // params.inCurrency = inCurrency;
      }
      if (outCurrency) {
        params.outCurrency = outCurrency;
      }

      var output = [];
      var request = api.hasAccount ? api.authGET('trades/payment-methods', params) : api.GET('trades/payment-methods', params);
      return request.then(function (res) {
        output = {};
        for (var i = 0; i < res.length; i++) {
          var medium = new PaymentMedium(res[i], api, quote);
          if (inCurrency !== 'BTC') {
            // Buy
            output[medium.inMedium] = medium;
          } else {
            // Sell
            output[medium.outMedium] = medium;
          }
        }
        return Promise.resolve(output);
      });
    }
  }]);

  return PaymentMedium;
}(ExchangePaymentMedium);

module.exports = PaymentMedium;