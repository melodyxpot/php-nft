'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Helpers = require('./helpers');
var assert = require('assert');

var Quote = function () {
  function Quote(api, delegate, TradeClass, PaymentMediumClass) {
    _classCallCheck(this, Quote);

    assert(this.constructor !== Quote, 'Abstract Class');
    assert(api, 'API required');
    assert(delegate, 'ExchangeDelegate required');
    assert(TradeClass, 'Trade class required');
    assert(PaymentMediumClass, 'PaymentMedium class required');
    assert(PaymentMediumClass.getAll, 'PaymentMedium.getAll missing');
    assert(TradeClass.buy, 'Trade.buy() missing');

    this._api = api;
    this._delegate = delegate;
    this._TradeClass = TradeClass;
    this._PaymentMediumClass = PaymentMediumClass;
    this._timeOfRequest = new Date().getTime();

    this._paymentMediums = null;
  }

  _createClass(Quote, [{
    key: 'getPaymentMediums',
    value: function getPaymentMediums() {
      var self = this;

      var setPaymentMediums = function setPaymentMediums(paymentMediums) {
        self._paymentMediums = paymentMediums;
        return self.paymentMediums;
      };

      var inCurrency = this.baseCurrency;
      var outCurrency = this.quoteCurrency;
      if (this.baseCurrency === 'BTC' && this.baseAmount > 0) {
        inCurrency = this.quoteCurrency;
        outCurrency = this.baseCurrency;
      }
      if (this.paymentMediums) {
        return Promise.resolve(this.paymentMediums);
      } else {
        return this._PaymentMediumClass.getAll(inCurrency, outCurrency, this._api, this).then(setPaymentMediums);
      }
    }
  }, {
    key: 'getPayoutMediums',
    value: function getPayoutMediums() {
      var self = this;
      var outCurrency = void 0;
      if (this.baseCurrency === 'BTC') {
        outCurrency = this.quoteCurrency;
      } else {
        outCurrency = this.baseCurrency;
      }
      var setPaymentMediums = function setPaymentMediums(paymentMediums) {
        self._paymentMediums = paymentMediums;
        return self.paymentMediums;
      };
      return this._PaymentMediumClass.getAll('BTC', outCurrency, this._api, this).then(setPaymentMediums);
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'debug',
    get: function get() {
      return this._debug;
    },
    set: function set(value) {
      this._debug = Boolean(value);
    }
  }, {
    key: 'api',
    get: function get() {
      return this._api;
    }
  }, {
    key: 'delegate',
    get: function get() {
      return this._delegate;
    }
  }, {
    key: 'baseCurrency',
    get: function get() {
      return this._baseCurrency;
    }
  }, {
    key: 'quoteCurrency',
    get: function get() {
      return this._quoteCurrency;
    }
  }, {
    key: 'feeCurrency',
    get: function get() {
      return this._feeCurrency;
    }
  }, {
    key: 'baseAmount',
    get: function get() {
      return this._baseAmount;
    }
  }, {
    key: 'quoteAmount',
    get: function get() {
      return this._quoteAmount;
    }
  }, {
    key: 'feeAmount',
    get: function get() {
      return this._feeAmount;
    }
  }, {
    key: 'expiresAt',
    get: function get() {
      return this._expiresAt;
    }
  }, {
    key: 'timeOfRequest',
    get: function get() {
      return this._timeOfRequest;
    }
  }, {
    key: 'timeToExpiration',
    get: function get() {
      return this._expiresAt - this._timeOfRequest - 1000;
    }
  }, {
    key: 'paymentMediums',
    get: function get() {
      return this._paymentMediums;
    }
  }], [{
    key: 'getQuote',
    value: function getQuote(amount, baseCurrency, quoteCurrency, supportedCurrencies, debug) {
      assert(Helpers.isInteger(amount), 'amount must be in cents or satoshi');

      if (supportedCurrencies.indexOf(baseCurrency) === -1) {
        return Promise.reject('base_currency_not_supported');
      }

      if (supportedCurrencies.indexOf(quoteCurrency) === -1) {
        return Promise.reject('quote_currency_not_supported');
      }

      // istanbul ignore if
      if (baseCurrency === 'CNY' || quoteCurrency === 'CNY') {
        console.warn('CNY has only 1 decimal place');
      }

      var baseAmount;
      if (baseCurrency === 'BTC') {
        baseAmount = (amount / 100000000).toFixed(8);
      } else {
        baseAmount = (amount / 100).toFixed(2);
      }
      return Promise.resolve(baseAmount);
    }
  }]);

  return Quote;
}();

module.exports = Quote;