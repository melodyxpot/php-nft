'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var assert = require('assert');

var Trade = function () {
  function Trade(api, delegate) {
    _classCallCheck(this, Trade);

    assert(this.constructor !== Trade, 'Abstract Class');
    assert(this.refresh, 'Subclass must implement refresh()');
    assert(api, 'API missing');
    assert(delegate, 'delegate missing');
    assert(typeof delegate.getReceiveAddress === 'function', 'delegate requires getReceiveAddress()');
    this._delegate = delegate;
    this._api = api;
  }

  _createClass(Trade, [{
    key: 'self',
    value: function self() {
      return this;
    }
  }, {
    key: 'process',
    value: function process() {
      if (['rejected', 'cancelled', 'expired', 'failed'].indexOf(this.state) > -1) {
        /* istanbul ignore if */
        if (this.debug) {
          console.info('Check if address for ' + this.state + ' trade ' + this.id + ' can be released');
        }
        this._delegate.releaseReceiveAddress(this);
      }
    }

    // Checks the balance for the receive address and monitors the websocket if needed:
    // Call this method long before the user completes the purchase:
    // trade.watchAddress.then(() => ...);

  }, {
    key: 'watchAddress',
    value: function watchAddress() {
      /* istanbul ignore if */
      if (this.debug) {
        console.info('Watch ' + this.receiveAddress + ' for ' + this.state + ' trade ' + this.id);
      }
      // Check if this transaction is already marked as paid:
      if (this._txHash) {
        /* istanbul ignore if */
        if (this.debug) {
          console.info("Already paid, resolve immedidately and don't watch.");
        }
        return Promise.resolve();
      }
      var self = this;
      var promise = new Promise(function (resolve, reject) {
        self._watchAddressResolve = resolve;
      });
      return promise;
    }
  }, {
    key: '_monitorAddress',
    value: function _monitorAddress() {
      var _this = this;

      var save = function save() {
        return _this._delegate.save.bind(_this._delegate)();
      };

      var self = this;

      this._delegate.monitorAddress(this.receiveAddress, function (hash, amount) {
        var checkAddress = function checkAddress() {
          return self._setTransactionHash({ hash: hash }, amount, self._delegate);
        };
        if (self.state === 'completed' || self.state === 'processing' || self.state === 'completed_test') {
          return Promise.resolve().then(checkAddress).then(save);
        } else {
          return self.refresh().then(checkAddress).then(save);
        }
      });
    }
  }, {
    key: '_setTransactionHash',


    //
    value: function _setTransactionHash(tx, amount, delegate) {
      var self = this;
      var setConfirmations = function setConfirmations(tx) {
        self._confirmations = tx.confirmations;
        // TODO: refactor
        if (self.confirmed) {
          self._confirmed = true;
        }
      };

      /* istanbul ignore if */
      if (self.debug) {
        console.info('Transaction ' + tx.hash + ' detected, considering ' + self.state + ' trade ' + self.id);
      }
      if (self.state === 'completed_test') {
        if (!self.confirmations && !self._txHash) {
          // For test trades, there is no real transaction, so trade._txHash is not
          // set. Instead use the hash for the incoming transaction. This will not
          // work correctly with address reuse.
          /* istanbul ignore if */
          if (self.debug) {
            console.info('Test trade, not matched before, unconfirmed transaction, assuming match');
          }
          self._txHash = tx.hash;
          setConfirmations(tx);
          self._watchAddressResolve && self._watchAddressResolve();
        } else {
          /* istanbul ignore if */
          if (self.debug) {
            console.info('Trade already matched, not calling _watchAddressResolve()');
          }
          if (self._txHash === tx.hash) {
            setConfirmations(tx);
          }
        }
        /* istanbul ignore else */
      } else if (self.state === 'completed' || self.state === 'processing') {
        if (self._txHash) {
          // Multiple trades may reuse the same address if e.g. one is
          // cancelled of if we reach the gap limit.
          /* istanbul ignore if */
          if (self.debug) {
            console.info('Trade already matched, not calling _watchAddressResolve()');
          }
          if (self._txHash === tx.hash) {
            setConfirmations(tx);
          } else {
            // Different trade, ignore
          }
        } else {
          // transferOut.details.transaction is not implemented and might be
          // missing if in the processing state.
          /* istanbul ignore if */
          if (self.debug) {
            console.info('Trade not matched yet, assuming match');
          }
          self._txHash = tx.hash;
          setConfirmations(tx);
        }
        self._watchAddressResolve && self._watchAddressResolve();
      } else {
        /* istanbul ignore if */
        if (self.debug) {
          console.info('Not calling _watchAddressResolve()');
        }
      }
    }
  }, {
    key: 'debug',
    get: function get() {
      return this._debug;
    },
    set: function set(value) {
      this._debug = Boolean(value);
    }
  }, {
    key: 'id',
    get: function get() {
      return this._id;
    }
  }, {
    key: 'createdAt',
    get: function get() {
      return this._createdAt;
    }
  }, {
    key: 'inCurrency',
    get: function get() {
      return this._inCurrency;
    }
  }, {
    key: 'outCurrency',
    get: function get() {
      return this._outCurrency;
    }
  }, {
    key: 'inAmount',
    get: function get() {
      return this._inAmount;
    }
  }, {
    key: 'medium',
    get: function get() {
      return this._medium;
    }
  }, {
    key: 'state',
    get: function get() {
      return this._state;
    }
  }, {
    key: 'sendAmount',
    get: function get() {
      return this._sendAmount;
    }
  }, {
    key: 'outAmount',
    get: function get() {
      return this._outAmount;
    }
  }, {
    key: 'outAmountExpected',
    get: function get() {
      return this._outAmountExpected;
    }
  }, {
    key: 'receiveAddress',
    get: function get() {
      return this._receiveAddress;
    }
  }, {
    key: 'accountIndex',
    get: function get() {
      return this._account_index;
    }
  }, {
    key: 'bitcoinReceived',
    get: function get() {
      return Boolean(this._txHash);
    }
  }, {
    key: 'confirmed',
    get: function get() {
      return this._confirmed || this._confirmations >= 3;
    }
  }, {
    key: 'txHash',
    get: function get() {
      return this._txHash || null;
    }
  }], [{
    key: '_checkOnce',
    value: function _checkOnce(trades, delegate) {
      assert(delegate, '_checkOnce needs delegate');

      if (trades.length === 0) {
        return Promise.resolve();
      }

      /* istanbul ignore if */
      if (delegate.debug) {
        console.info('_checkOnce', trades.map(function (trade) {
          return trade.id;
        }).join(', '));
      }

      var promises = trades.map(function (trade) {
        return delegate.checkAddress(trade.receiveAddress).then(function (tx, amount) {
          if (!tx) return;

          /* istanbul ignore if */
          if (delegate.debug) {
            console.info('checkAddress', trade.receiveAddress, 'found transaction');
          }

          var setTransactionHash = function setTransactionHash() {
            return trade._setTransactionHash(tx, amount, delegate);
          };

          if (trade.state === 'completed' || trade.state === 'processing' || trade.state === 'completed_test') {
            return setTransactionHash();
          } else {
            return trade.refresh().then(setTransactionHash);
          }
        });
      });

      return Promise.all(promises).then(delegate.save.bind(delegate));
    }
  }, {
    key: 'buy',
    value: function buy(quote, medium, request) {
      assert(quote, 'Quote required');
      assert(quote.expiresAt > new Date(), 'QUOTE_EXPIRED');

      /* istanbul ignore if */
      if (quote.debug) {
        console.info('Reserve receive address for new trade');
      }
      var reservation = quote.delegate.reserveReceiveAddress();

      var processTrade = function processTrade(res) {
        var trade = new quote._TradeClass(res, quote.api, quote.delegate);
        trade.debug = quote.debug;

        /* istanbul ignore if */
        if (quote.debug) {
          console.info('Commit receive address for new trade');
        }
        reservation.commit(trade);

        /* istanbul ignore if */
        if (quote.debug) {
          console.info('Monitor trade', trade.receiveAddress);
        }
        trade._monitorAddress.bind(trade)();
        return trade;
      };

      var error = function error(e) {
        console.error(e);
        return Promise.reject(e);
      };

      return request(reservation.receiveAddress).then(processTrade).catch(error);
    }
  }, {
    key: '_monitorWebSockets',
    value: function _monitorWebSockets(trades) {
      for (var i = 0; i < trades.length; i++) {
        var trade = trades[i];
        trade._monitorAddress.bind(trade)();
      }
    }

    // Monitor the receive addresses for pending and completed trades.

  }, {
    key: 'monitorPayments',
    value: function monitorPayments(trades, delegate) {
      /* istanbul ignore if */
      if (delegate.debug) {
        console.info('monitorPayments');
      }

      assert(delegate, '_monitorPayments needs delegate');

      var tradeFilter = function tradeFilter(trade) {
        return ['awaiting_transfer_in', 'reviewing', 'processing', 'completed', 'completed_test'].indexOf(trade.state) > -1 && !trade.confirmed;
      };

      var filteredTrades = trades.filter(tradeFilter);

      Trade._checkOnce(filteredTrades, delegate).then(function () {
        Trade._monitorWebSockets(filteredTrades);
      });
    }
  }, {
    key: 'filteredTrades',
    value: function filteredTrades(trades) {
      return trades.filter(function (trade) {
        // Only consider transactions that are complete or that we're still
        // expecting payment for:
        return ['awaiting_transfer_in', 'processing', 'reviewing', 'completed', 'completed_test'].indexOf(trade.state) > -1;
      });
    }
  }]);

  return Trade;
}();

module.exports = Trade;